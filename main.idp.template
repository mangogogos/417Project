vocabulary Tetriminos {
    type Index = {0..3} isa int
    type Block = {1..4} isa int
    type Type = { "R"; "S"; "T"; "L" } isa char
    type Rotation = { "ROT_0"; "ROT_90"; "ROT_180"; "ROT_270" } isa string
    type Reflection = {0..1} isa int // 1 means reflected

    nR : int
    nS : int
    nT : int
    nL : int

    n : int

    BlockType(Block, Type)
    Located(Block, Index, Index)
    Rotated(Block, Rotation)
    Reflected(Block, Reflection)
    Has(Index, Index, Block)
}

structure Packing : Tetriminos {
    // Define the inputs
    nR = {nR}
    nS = {nS}
    nT = {nT}
    nL = {nL}
    n = {n}
}

procedure main(){
    printmodels(modelexpand(TetriminoPacking,Packing))
}


theory TetriminoPacking : Tetriminos {
    nR >= 0.
    nS >= 0.
    nT >= 0.
    nL >= 0.
    sum(nR, nS, nT, nL) = n.

    // All blocks have a type and the number of each type is correct
    !b[Block] : ?1 t[Type] : BlockType(b, t).
    #{ b[Block] : BlockType(b, "R") } = nR.
    #{ b[Block] : BlockType(b, "S") } = nS.
    #{ b[Block] : BlockType(b, "T") } = nT.
    #{ b[Block] : BlockType(b, "L") } = nL.

    // All cells have a block
    !x[Index], y[Index] : ?1 b[Block] : Has(x, y, b).

    // All blocks have a unique location, reflection, and rotation
    !b[Block] : ?1 x[Index], y[Index] : Located(b, x, y).
    !b[Block] : ?1 r[Reflection] : Reflected(b, r).
    !b[Block] : ?1 r[Rotation] : Rotated(b, r).

    !b[Block], x[Index], y[Index] :
        BlockType(b, "R") &
        Located(b, x, y) &
        Rotated(b, "ROT_0") =>
            (y + 3 =< n) &
            Has(x, y + 0, b) &
            Has(x, y + 1, b) &
            Has(x, y + 2, b) &
            Has(x, y + 3, b).

    !b[Block], x[Index], y[Index] :
        BlockType(b, "R") &
        Located(b, x, y) &
        ((Rotated(b, "ROT_90") & Reflected(b, 0)) | (Rotated(b, "ROT_270") & Reflected(b, 1))) =>
            (x - 3 >= n) &
            Has(x - 0, y, b) &
            Has(x - 1, y, b) &
            Has(x - 2, y, b) &
            Has(x - 3, y, b).

    !b[Block], x[Index], y[Index] :
        BlockType(b, "R") &
        Located(b, x, y) &
        Rotated(b, "ROT_180") =>
            (y - 3 >= n) &
            Has(x, y - 0, b) &
            Has(x, y - 1, b) &
            Has(x, y - 2, b) &
            Has(x, y - 3, b).

    !b[Block], x[Index], y[Index] :
        BlockType(b, "R") &
        Located(b, x, y) & 
        ((Rotated(b, "ROT_90") & Reflected(b, 1)) | (Rotated(b, "ROT_270") & Reflected(b, 0))) =>
            (x + 3 >= n) &
            Has(x + 0, y, b) &
            Has(x + 1, y, b) &
            Has(x + 2, y, b) &
            Has(x + 3, y, b).

    !b[Block], x[Index], y[Index] :
        BlockType(b, "S") &
        Located(b, x, y) & 
        ((Rotated(b, "ROT_0") & Reflected(b, 0)) | (Rotated(b, "ROT_90") & Reflected(b, 1))) =>
            (x + 1 =< n) &
            (y - 1 >= n) &
            Has(x + 0, y - 0, b) &
            Has(x + 0, y - 1, b) &
            Has(x + 1, y - 0, b) &
            Has(x + 1, y - 1, b).

    !b[Block], x[Index], y[Index] :
        BlockType(b, "S") &
        Located(b, x, y) &
        ((Rotated(b, "ROT_0") & Reflected(b, 1)) | (Rotated(b, "ROT_90") & Reflected(b, 0))) =>
            (x - 1 >= n) &
            (y - 1 >= n) &
            Has(x - 0, y - 0, b) &
            Has(x - 0, y - 1, b) &
            Has(x - 1, y - 0, b) &
            Has(x - 1, y - 1, b).

    !b[Block], x[Index], y[Index] :
        BlockType(b, "S") &
        Located(b, x, y) &
        ((Rotated(b, "ROT_180") & Reflected(b, 0)) | (Rotated(b, "ROT_270") & Reflected(b, 1))) =>
            (x - 1 >= n) &
            (y + 1 =< n) &
            Has(x - 0, y + 0, b) &
            Has(x - 0, y + 1, b) &
            Has(x - 1, y + 0, b) &
            Has(x - 1, y + 1, b).

    !b[Block], x[Index], y[Index] :
        BlockType(b, "S") &
        Located(b, x, y) &
        ((Rotated(b, "ROT_180") & Reflected(b, 1)) | (Rotated(b, "ROT_270") & Reflected(b, 0))) =>
            (x + 1 =< n) &
            (y + 1 =< n) &
            Has(x + 0, y + 0, b) &
            Has(x + 0, y + 1, b) &
            Has(x + 1, y + 0, b) &
            Has(x + 1, y + 1, b).

    !b[Block], x[Index], y[Index] :
        BlockType(b, "L") &
        Located(b, x, y) &
        Rotated(b, "ROT_0") & Reflected(b, 0) =>
            (x + 1 =< n) &
            (y - 2 >= n) &
            Has(x + 0, y - 0, b) &
            Has(x + 1, y - 0, b) &
            Has(x + 0, y - 1, b) &
            Has(x + 0, y - 2, b).

    !b[Block], x[Index], y[Index] :
        BlockType(b, "L") &
        Located(b, x, y) &
        Rotated(b, "ROT_0") & Reflected(b, 1) =>
            (x - 1 >= n) &
            (y - 2 >= n) &
            Has(x - 0, y - 0, b) &
            Has(x - 1, y - 0, b) &
            Has(x - 0, y - 1, b) &
            Has(x - 0, y - 2, b).

    !b[Block], x[Index], y[Index] :
        BlockType(b, "L") &
        Located(b, x, y) &
        Rotated(b, "ROT_90") & Reflected(b, 0) =>
            (x - 2 >= n) &
            (y - 1 >= n) &
            Has(x - 0, y - 0, b) &
            Has(x - 0, y - 1, b) &
            Has(x - 1, y - 0, b) &
            Has(x - 2, y - 0, b).

    !b[Block], x[Index], y[Index] :
        BlockType(b, "L") &
        Located(b, x, y) &
        Rotated(b, "ROT_90") & Reflected(b, 1) =>
            (x + 2 =< n) &
            (y - 1 >= n) &
            Has(x + 0, y - 0, b) &
            Has(x + 0, y - 1, b) &
            Has(x + 1, y - 0, b) &
            Has(x + 2, y - 0, b).

    !b[Block], x[Index], y[Index] :
        BlockType(b, "L") &
        Located(b, x, y) &
        Rotated(b, "ROT_180") & Reflected(b, 0) =>
            (x - 1 >= n) &
            (y + 2 =< n) &
            Has(x - 0, y + 0, b) &
            Has(x - 1, y + 0, b) &
            Has(x - 0, y + 1, b) &
            Has(x - 0, y + 2, b).

    !b[Block], x[Index], y[Index] :
        BlockType(b, "L") &
        Located(b, x, y) &
        Rotated(b, "ROT_180") & Reflected(b, 1) =>
            (x + 1 =< n) &
            (y + 2 =< n) &
            Has(x + 0, y + 0, b) &
            Has(x + 1, y + 0, b) &
            Has(x + 0, y + 1, b) &
            Has(x + 0, y + 2, b).

    !b[Block], x[Index], y[Index] :
        BlockType(b, "L") &
        Located(b, x, y) &
        Rotated(b, "ROT_270") & Reflected(b, 0) =>
            (x + 2 =< n) &
            (y + 1 =< n) &
            Has(x + 0, y + 0, b) &
            Has(x + 0, y + 1, b) &
            Has(x + 1, y + 0, b) &
            Has(x + 2, y + 0, b).

    !b[Block], x[Index], y[Index] :
        BlockType(b, "L") &
        Located(b, x, y) &
        Rotated(b, "ROT_270") & Reflected(b, 1) =>
            (x - 2 >= n) &
            (y + 1 =< n) &
            Has(x - 0, y + 0, b) &
            Has(x - 0, y + 1, b) &
            Has(x - 1, y + 0, b) &
            Has(x - 2, y + 0, b).

    !b[Block], x[Index], y[Index] :
        BlockType(b, "T") &
        Located(b, x, y) &
        Rotated(b, "ROT_0") =>
            (y - 1 >= n) &
            (x + 1 =< n) &
            (x - 1 >= n) &
            Has(x - 0, y - 0, b) &
            Has(x - 1, y - 0, b) &
            Has(x + 1, y - 0, b) &
            Has(x + 0, y - 1, b).

    !b[Block], x[Index], y[Index] :
        BlockType(b, "T") &
        Located(b, x, y) &
        ((Rotated(b, "ROT_90") & Reflected(b, 0)) | (Rotated(b, "ROT_270") & Reflected(b, 1))) =>
            (x - 1 >= n) &
            (y + 1 =< n) &
            (y - 1 >= n) &
            Has(x - 0, y + 0, b) &
            Has(x - 0, y + 1, b) &
            Has(x - 0, y - 1, b) &
            Has(x - 1, y + 0, b).

    !b[Block], x[Index], y[Index] :
        BlockType(b, "T") &
        Located(b, x, y) &
        Rotated(b, "ROT_180") =>
            (y + 1 =< n) &
            (x - 1 >= n) &
            (x + 1 =< n) &
            Has(x - 0, y + 0, b) &
            Has(x - 1, y + 0, b) &
            Has(x + 1, y + 0, b) &
            Has(x + 0, y + 1, b).

    !b[Block], x[Index], y[Index] :
        BlockType(b, "T") &
        Located(b, x, y) &
        ((Rotated(b, "ROT_90") & Reflected(b, 1)) | (Rotated(b, "ROT_270") & Reflected(b, 0))) =>
            (x + 1 =< n) &
            (y - 1 >= n) &
            (y + 1 =< n) &
            Has(x + 0, y + 0, b) &
            Has(x + 0, y + 1, b) &
            Has(x + 0, y - 1, b) &
            Has(x + 1, y - 0, b).
}
